// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc319.SteamworksBob319.commands.DriveTrain;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.hal.HAL;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.hal.FRCNetComm.tInstances;
import edu.wpi.first.wpilibj.hal.FRCNetComm.tResourceType;

import org.usfirst.frc319.SteamworksBob319.Robot;

import com.ctre.CANTalon.TalonControlMode;

/**
 *
 */
public class VelocityDrive extends Command {

	public double highGearRPM = 850;//1015
	public double lowGearRPM = 468;
	public double deadband = 0.05;

	public VelocityDrive() {

		requires(Robot.driveTrain);

	}

	// Called just before this Command runs the first time
	protected void initialize() {
		Robot.driveTrain.setDrivetrainVelocityDrive();
		
	}

	// Called repeatedly when this Command is scheduled to run
	protected void execute() {
		double moveValue = Robot.oi.driverController.getLeftStickY();
		double rotateValue = Robot.oi.driverController.getRightStickX();

		if(Robot.driveTrain.isHighGear == true){
		SmartDashboard.putDouble("move value= ", moveValue);
		SmartDashboard.putDouble("rotate value", rotateValue);
			
		velociRaptorDrive(moveValue, -rotateValue, true, highGearRPM, deadband);
		}
		else{
			velociRaptorDrive(moveValue, -rotateValue,true, lowGearRPM, deadband);
		}
	}

	// Make this return true when this Command no longer needs to run execute()
	protected boolean isFinished() {
		return false;
	}

	// Called once after isFinished returns true
	protected void end() {
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	protected void interrupted() {
	}

	// caps speed to full throttle
	protected static double limit(double num) {
		if (num > 1.0) {
			return 1.0;
		}
		if (num < -1.0) {
			return -1.0;
		}
		return num;
	}

	public void velociRaptorDrive(double moveValue, double rotateValue, boolean squaredInputs, double maxRPM,
			double deadband) {
		// local variables to hold the computed PWM values for the motors

		double leftMotorSpeed;
		double rightMotorSpeed;

		if (moveValue > -deadband && moveValue < deadband && rotateValue >-deadband && rotateValue < deadband) {
			Robot.driveTrain.leftDriveLead.changeControlMode(TalonControlMode.PercentVbus);
			Robot.driveTrain.rightDriveLead.changeControlMode(TalonControlMode.PercentVbus);
			maxRPM = 1;
		} else {
			Robot.driveTrain.changeDriveTrainControlModeToSpeed();
			if (moveValue > deadband) {
				//Robot.driveTrain.leftDriveLead.configPeakOutputVoltage(0.0f, -12.0f);
				//Robot.driveTrain.rightDriveLead.configPeakOutputVoltage(12.0f, 0.0f);
				Robot.driveTrain.leftDriveLead.configPeakOutputVoltage(+12.0f, -12.0f);
				Robot.driveTrain.rightDriveLead.configPeakOutputVoltage(+12.0f, -12.0f);
				
			} else if (moveValue < -deadband) {
				
				//Robot.driveTrain.leftDriveLead.configPeakOutputVoltage(+12.0f, 0.0f);
				//Robot.driveTrain.rightDriveLead.configPeakOutputVoltage(0.0f, -12.0f);
				Robot.driveTrain.leftDriveLead.configPeakOutputVoltage(+12.0f, -12.0f);
				Robot.driveTrain.rightDriveLead.configPeakOutputVoltage(+12.0f, -12.0f);
				
				
			}
		}

		moveValue = limit(moveValue);
		rotateValue = limit(rotateValue);

		if (squaredInputs) {
			// square the inputs (while preserving the sign) to increase fine
			// control
			// while permitting full power
			if (moveValue >= 0.0) {
				moveValue = moveValue * moveValue;
			} else {
				moveValue = -(moveValue * moveValue);
			}
			if (rotateValue >= 0.0) {
				rotateValue = rotateValue * rotateValue;
			} else {
				rotateValue = -(rotateValue * rotateValue);
			}
		}

		if (moveValue > 0.0) {
			if (rotateValue > 0.0) {
				leftMotorSpeed = moveValue - rotateValue;
				rightMotorSpeed = Math.max(moveValue, rotateValue);
			} else {
				leftMotorSpeed = Math.max(moveValue, -rotateValue);
				rightMotorSpeed = moveValue + rotateValue;
			}
		} else {
			if (rotateValue > 0.0) {
				leftMotorSpeed = -Math.max(-moveValue, rotateValue);
				rightMotorSpeed = moveValue + rotateValue;
			} else {
				leftMotorSpeed = moveValue - rotateValue;
				rightMotorSpeed = -Math.max(-moveValue, -rotateValue);
			}
		}

		// scale for velocity because the talons require rpm in speed mode
		leftMotorSpeed = leftMotorSpeed * maxRPM;
		rightMotorSpeed = rightMotorSpeed * maxRPM;

		

		// setLeftRightMotorOutputs(leftMotorSpeed, rightMotorSpeed);
		Robot.driveTrain.setLeftRightMotors(leftMotorSpeed, rightMotorSpeed);
	}
}
