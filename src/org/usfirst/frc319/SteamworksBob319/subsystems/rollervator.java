// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc319.SteamworksBob319.subsystems;

import org.usfirst.frc319.SteamworksBob319.Robot;
import org.usfirst.frc319.SteamworksBob319.RobotMap;
import org.usfirst.frc319.SteamworksBob319.commands.*;
import org.usfirst.frc319.SteamworksBob319.commands.Rollervator.ClimbStart;
import org.usfirst.frc319.SteamworksBob319.commands.Rollervator.RollervatorPIDTestMode;
import org.usfirst.frc319.SteamworksBob319.commands.Rollervator.RollervatorStop;

import com.ctre.CANTalon;
import com.ctre.CANTalon.FeedbackDevice;
import com.ctre.CANTalon.TalonControlMode;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class rollervator extends Subsystem {

	public final CANTalon rollervatorLead = RobotMap.rollervatorRollervatorLead;
	public final CANTalon rollervatorFollow = RobotMap.rollervatorRollervatorFollow;
	
	private final int SHOOT_PROFILE = 0;
	private final int CLIMB_PROFILE = 1;
	
	private double pShoot = 0.06;
	private double fShoot = 0.1;
	private double dShoot = 0.0;
	private double iShoot = 0.08;
	private int iZoneShoot = 500;
	
	private double pClimb = 0.06;
	private double fClimb = 0.1;
	private double dClimb = 0.0;
	private double iClimb = 0.0;

	StringBuilder _sb = new StringBuilder(); // used for tuning PID
	int _loops = 0; // used for tuning PID

	public rollervator() {

		rollervatorLead.changeControlMode(TalonControlMode.Speed);
		rollervatorLead.enableBrakeMode(false);
		rollervatorFollow.enableBrakeMode(false);

		rollervatorLead.setFeedbackDevice(FeedbackDevice.CtreMagEncoder_Relative);
		rollervatorLead.reverseOutput(false);
		rollervatorLead.reverseSensor(true);

		rollervatorFollow.changeControlMode(TalonControlMode.Follower);
		rollervatorFollow.set(rollervatorLead.getDeviceID());
		rollervatorFollow.reverseOutput(true);
		// talon7.reverseSensor(true); There is no sensor, doing this for
		// continuity

		rollervatorLead.configNominalOutputVoltage(+0.0f, -0.0f);
		rollervatorLead.configPeakOutputVoltage(12.0, 0.0);
		rollervatorFollow.configPeakOutputVoltage(-12.0, -0.0);
		
		rollervatorLead.setPID(pShoot, iShoot, dShoot, fShoot, iZoneShoot, 0, SHOOT_PROFILE);		
		rollervatorLead.setPID(pClimb, iClimb, dClimb, fClimb, 0, 0, CLIMB_PROFILE);
		
		rollervatorLead.setVoltageRampRate(36);

	}

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {

		// setDefaultCommand(new MotorTest(this,
		// RobotMap.rollervatorRollervatorLead));
		//setDefaultCommand(new RollervatorStop());
		//setDefaultCommand(new ClimbStart());
		// Set the default command for a subsystem here.

	}

	public void rollervatorStop() {
		rollervatorLead.changeControlMode(TalonControlMode.PercentVbus);// used
																		// to
																		// let
																		// rollervator
																		// to
																		// coast
																		// to
																		// zero
																		// speed
		rollervatorLead.set(0);
	}
	
	public void set(double setpoint){
		rollervatorLead.set(setpoint);
	}

	public void rollervatorShoot(double speed) {
		rollervatorLead.changeControlMode(TalonControlMode.Speed);
		rollervatorLead.setProfile(SHOOT_PROFILE);
		rollervatorLead.set(speed);
	}

	public void rollervatorClimb(double power) {
		rollervatorLead.changeControlMode(TalonControlMode.Speed);
		rollervatorLead.setProfile(CLIMB_PROFILE);
		rollervatorLead.set(power);
	}

	public void changeModeToSpeed() {
		rollervatorLead.changeControlMode(TalonControlMode.Speed);
	}

	public void changeModeToVbus() {
		rollervatorLead.changeControlMode(TalonControlMode.PercentVbus);
	}

	// ---USED for tuning rollervator Velocity PID -----//
	public void rollervatorPIDTestMode() {

		/* get gamepad axis */
		double leftYstick = -Robot.oi.operatorController.getLeftStickY();
		double motorOutput = rollervatorLead.getOutputVoltage() / rollervatorLead.getBusVoltage();
		/* prepare line to print */
		_sb.append("\tout:");
		_sb.append(motorOutput);
		_sb.append("\tspd:");
		_sb.append(rollervatorLead.getSpeed());

		if (Robot.oi.operatorController.getRawButton(1)) {
			/* Speed mode */
			double targetSpeed = 1000; /* 1500 RPM in either direction */
			rollervatorLead.changeControlMode(TalonControlMode.Speed);
			rollervatorLead.set(targetSpeed); /* 1500 RPM in either direction */
			// _sb.append(_talon.getControlMode() );

			// System.out.println(_talonFollower.getControlMode() );
			/* append more signals to print when in speed mode. */
			_sb.append("\terr:");
			_sb.append(rollervatorLead.getClosedLoopError());
			_sb.append("\ttrg:");
			_sb.append(targetSpeed);
		} else if (Robot.oi.operatorController.getRawButton(2)) {
			rollervatorLead.set(-.6);
			// System.out.println(_talon.getControlMode() );
			// System.out.println(_talonFollower.getControlMode() );
			// System.out.println("constant voltage mode");
		}

		else {
			/* Percent voltage mode */
			// System.out.println(_talon.getControlMode() );
			// System.out.println(_talonFollower.getControlMode() );
			rollervatorLead.changeControlMode(TalonControlMode.PercentVbus);
			rollervatorLead.set(Robot.oi.operatorController.getLeftStickY());
			// System.out.println("joystick vbus mode");
		}

		if (++_loops >= 10) {
			_loops = 0;
			System.out.println(_sb.toString());
		}
		_sb.setLength(0);
	}

	// ----- All of the information that could be used by the rollervator
	// ------//

	public double getRollervatorSpeed() {
		return rollervatorLead.getSpeed();
	}

	public double getRollervatorCurrent() {
		return rollervatorLead.getOutputCurrent();
	}
	
	public double getRollerVatorFollowCurrent(){
		return rollervatorFollow.getOutputCurrent();
	}
	
	public double getRollervatorLeadVoltage(){
		return rollervatorLead.getOutputVoltage();
	}
	
	public double getRollervatorFollowVoltage(){
		return rollervatorFollow.getOutputVoltage();
	}

	// --- could be used as an isfinished to cut the motor off if current is
	// exceeded ---///
	public boolean isExceedingCurrentThreshhold(double threshhold) {
		if (rollervatorLead.getOutputCurrent() > threshhold) {
			return true;
		} else
			return false;
	}

}
